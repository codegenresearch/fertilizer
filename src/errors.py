import sys\nfrom time import sleep, time, exp\nimport requests\nfrom colorama import Fore\n\ndef handle_error(\n  description: str,\n  exception_details: (str | None) = None,\n  wait_time: int = 0,\n  extra_description: str = "",\n  should_exit: bool = False,\n) -> None:\n  action = "Exiting" if should_exit else "Retrying"\n  action += f" in {wait_time} seconds..." if wait_time else "..."\n  exception_message = f"\n{Fore.LIGHTBLACK_EX}{exception_details}" if exception_details is not None else ""\n\n  print(f"{Fore.RED}Error: {description}{extra_description}. {action}{exception_message}{Fore.RESET}")\n  sleep(wait_time)\n\n  if should_exit:\n    sys.exit(1)\n\nclass AuthenticationError(Exception):\n  pass\n\nclass TorrentDecodingError(Exception):\n  pass\n\nclass UnknownTrackerError(Exception):\n  pass\n\nclass TorrentNotFoundError(Exception):\n  pass\n\nclass TorrentAlreadyExistsError(Exception):\n  pass\n\nclass ConfigKeyError(Exception):\n  pass\n\nclass TorrentClientAuthenticationError(Exception):\n  pass\n\nclass TorrentClientError(Exception):\n  pass\n\nclass TorrentInjectionError(Exception):\n  pass\n\nclass RequestHandler:\n  def __init__(self, session, rate_limit, timeout, max_retries, max_retry_time):\n    self._session = session\n    self._rate_limit = rate_limit\n    self._timeout = timeout\n    self._last_used = 0\n    self._max_retries = max_retries\n    self._max_retry_time = max_retry_time\n    self._retry_wait_time = lambda x: min(int(exp(x)), self._max_retry_time)\n\n  def make_request(self, url, params):\n    current_retries = 1\n    while current_retries <= self._max_retries:\n      now = time()\n      if (now - self._last_used) > self._rate_limit:\n        self._last_used = now\n        try:\n          response = self._session.get(url, params=params, timeout=self._timeout)\n          response.raise_for_status()\n          return response.json()\n        except requests.exceptions.RequestException as e:\n          handle_error(\n            description=f"Request failed: {e}",\n            wait_time=self._retry_wait_time(current_retries),\n            extra_description=f" (attempt {current_retries}/{self._max_retries})",\n          )\n          current_retries += 1\n      else:\n        sleep(0.2)\n    handle_error(description="Maximum number of retries reached", should_exit=True)\n