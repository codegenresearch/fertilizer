import json\nimport requests\nfrom pathlib import Path\nfrom requests.structures import CaseInsensitiveDict\nfrom ..filesystem import url_join\nfrom ..parser import get_bencoded_data, calculate_infohash\nfrom ..errors import TorrentClientError, TorrentClientAuthenticationError, TorrentExistsInClientError\nfrom .torrent_client import TorrentClient\nclass Qbittorrent(TorrentClient):\n    def __init__(self, qbit_url):\n        super().__init__()\n        self._qbit_url_parts = self._extract_credentials_from_url(qbit_url, "/api/v2")\n        self._qbit_cookie = None\n\n    def setup(self):\n        self.__authenticate()\n        return self\n\n    def get_torrent_info(self, infohash):\n        response = self.__wrap_request("torrents/info", data={"hashes": infohash})\n        if response:\n            parsed_response = json.loads(response)\n            if not parsed_response:\n                raise TorrentClientError(f"Torrent not found in client ({infohash})")\n            torrent = parsed_response[0]\n            torrent_completed = torrent["progress"] == 1.0 or torrent["state"] == "pausedUP" or torrent["completion_on"] > 0\n            return {\n                "complete": torrent_completed,\n                "label": torrent["category"],\n                "save_path": torrent["save_path"],\