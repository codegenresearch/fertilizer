import os\nimport copy\nimport bencoder\nfrom hashlib import sha1\nfrom .utils import flatten, copy_and_mkdir\nfrom .trackers import RedTracker, OpsTracker\nfrom .errors import TorrentDecodingError\n\ndef is_valid_infohash(infohash: str) -> bool:\n    """Check if the provided infohash is a valid SHA-1 hash."""\n    if not isinstance(infohash, str) or len(infohash) != 40:\n        return False\n    try:\n        int(infohash, 16)\n        return True  # If conversion to int is successful, it's a valid hex string\n    except ValueError:\n        return False\n\ndef get_source(torrent_data: dict) -> bytes | None:\n    """Retrieve the source from torrent data."""\n    return torrent_data.get(b"info", {}).get(b"source")\n\ndef get_name(torrent_data: dict) -> bytes | None:\n    """Retrieve the name from torrent data."""\n    return torrent_data.get(b"info", {}).get(b"name")\n\ndef get_announce_url(torrent_data: dict) -> list[bytes] | None:\n    """Retrieve announce URLs from torrent data."""\n    from_announce = torrent_data.get(b"announce")\n    if from_announce:\n        return [from_announce] if isinstance(from_announce, bytes) else from_announce  # Ensure list format for consistency\n    \\\\\n    from_trackers = torrent_data.get(b"trackers")\n    if from_trackers:\n        return flatten(from_trackers)\n    \\\\\n    return None\n\ndef get_origin_tracker(torrent_data: dict) -> RedTracker | OpsTracker | None:\n    """Determine the origin tracker based on torrent data."""\n    source = get_source(torrent_data) or b""\n    announce_urls = get_announce_url(torrent_data) or []\n    \\\\\n    if source in RedTracker.source_flags_for_search() or any(RedTracker.announce_url() in url for url in announce_urls):\n        return RedTracker  # Return RedTracker if source or announce URL matches\n    \\"""\