import os\nimport copy\nimport bencoder\nfrom hashlib import sha1\nfrom .utils import flatten\nfrom .trackers import RedTracker, OpsTracker\nfrom .errors import TorrentDecodingError\n\ndef is_valid_infohash(infohash: str) -> bool:\n    """Check if the provided infohash is a valid SHA-1 hash."""\n    return isinstance(infohash, str) and len(infohash) == 40 and all(c in '0123456789abcdefABCDEF' for c in infohash)\n\ndef get_source(torrent_data: dict) -> bytes | None:\n    """Retrieve the source from torrent data."""\n    return torrent_data.get(b"info", {}).get(b"source")\n\ndef get_name(torrent_data: dict) -> bytes | None:\n    """Retrieve the name from torrent data."""\n    return torrent_data.get(b"info", {}).get(b"name")\n\ndef get_announce_url(torrent_data: dict) -> list[bytes]:\n    """Retrieve announce URLs from torrent data."""\n    announce = torrent_data.get(b"announce")\n    trackers = torrent_data.get(b"trackers")\n\n    if isinstance(announce, bytes):\n        return [announce]\n    elif isinstance(announce, list):\n        return announce\n    elif trackers:\n        return flatten(trackers)\n\n    return []\n\ndef get_origin_tracker(torrent_data: dict) -> RedTracker | OpsTracker | None:\n    """Determine the origin tracker based on torrent data."""\n    source = get_source(torrent_data) or b""\n    announce_urls = get_announce_url(torrent_data)\n\n    if source in RedTracker.source_flags_for_search() or any(RedTracker.announce_url() in url for url in announce_urls):\n        return RedTracker\n\n    if source in OpsTracker.source_flags_for_search() or any(OpsTracker.announce_url() in url for url in announce_urls):\n        return OpsTracker\n\n    return None\n\ndef calculate_infohash(torrent_data: dict) -> str:\n    """Calculate the infohash of the torrent data."""\n    info_data = torrent_data.get(b"info")\n    if not info_data:\n        raise TorrentDecodingError("Torrent data does not contain 'info' key")\n    return sha1(bencoder.encode(info_data))\n        .hexdigest()\n        .upper()\n\ndef recalculate_hash_for_new_source(torrent_data: dict, new_source: bytes | str) -> str:\n    """Recalculate the infohash for a new source."""\n    torrent_data = copy.deepcopy(torrent_data)\n    torrent_data[b"info"][b"source"] = new_source\n\n    return calculate_infohash(torrent_data)\n\ndef get_bencoded_data(filename: str) -> dict:\n    """Read and decode bencoded data from a file."""\n    try:\n        with open(filename, "rb") as f:\n            return bencoder.decode(f.read())\n    except Exception:\n        return None\n\ndef save_bencoded_data(filepath: str, torrent_data: dict) -> str:\n    """Save bencoded data to a file, creating parent directories if necessary."""\n    parent_dir = os.path.dirname(filepath)\n    if parent_dir:\n        os.makedirs(parent_dir, exist_ok=True)\n\n    with open(filepath, "wb") as f:\n        f.write(bencoder.encode(torrent_data))\n\n    return filepath\n