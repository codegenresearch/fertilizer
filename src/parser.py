import os\nimport copy\nimport bencoder\nfrom hashlib import sha1\nfrom .utils import flatten, copy_and_mkdir\nfrom .trackers import RedTracker, OpsTracker\nfrom .errors import TorrentDecodingError\n\ndef is_valid_infohash(infohash: str) -> bool:\n    """Check if the provided infohash is a valid SHA-1 hash."""\n    if not isinstance(infohash, str) or len(infohash) != 40:\n        return False\n    try:\n        int(infohash, 16)\n        return True  # If conversion to int is successful, it's a valid hex string\n    except ValueError:\n        return False\n\ndef get_source(torrent_data: dict) -> bytes | None:\n    """Retrieve the source from torrent data."""\n    try:\n        return torrent_data[b"info"][b"source"]\n    except KeyError:\n        return None\n\ndef get_name(torrent_data: dict) -> bytes | None:\n    """Retrieve the name from torrent data."""\n    try:\n        return torrent_data[b"info"][b"name"]\n    except KeyError:\n        return None\n\ndef get_announce_url(torrent_data: dict) -> list[bytes] | None:\n    """Retrieve announce URLs from torrent data."""\n    from_announce = torrent_data.get(b"announce")\n    if from_announce:\n        return [from_announce] if isinstance(from_announce, bytes) else from_announce  # Ensure list format for consistency\n\n    from_trackers = torrent_data.get(b"trackers")\n    if from_trackers:\n        return flatten(from_trackers)\n\n    return None\n\ndef get_origin_tracker(torrent_data: dict) -> RedTracker | OpsTracker | None:\n    """Determine the origin tracker based on torrent data."""\n    source = get_source(torrent_data) or b""\n    announce_urls = get_announce_url(torrent_data) or []\n\n    if source in RedTracker.source_flags_for_search() or any(RedTracker.announce_url() in url for url in announce_urls):\n        return RedTracker  # Return RedTracker if source or announce URL matches\n\n    if source in OpsTracker.source_flags_for_search() or any(OpsTracker.announce_url() in url for url in announce_urls):\n        return OpsTracker  # Return OpsTracker if source or announce URL matches\n\n    return None\n\ndef calculate_infohash(torrent_data: dict) -> str:\n    """Calculate the infohash of the torrent data."""\n    if b"info" not in torrent_data:\n        raise TorrentDecodingError("Torrent data does not contain 'info' key")\n    return sha1(bencoder.encode(torrent_data[b"info"]))\n        .hexdigest()\n        .upper()\n\ndef recalculate_hash_for_new_source(torrent_data: dict, new_source: bytes | str) -> str:\n    """Recalculate the infohash for a new source."""\n    torrent_data = copy.deepcopy(torrent_data)\n    torrent_data[b"info"][b"source"] = new_source\n\n    return calculate_infohash(torrent_data)\n\ndef get_bencoded_data(filename: str) -> dict:\n    """Read and decode bencoded data from a file."""\n    try:\n        with open(filename, "rb") as f:\n            data = bencoder.decode(f.read())\n        return data\n    except Exception as e:\n        raise TorrentDecodingError(f"Error decoding torrent file: {e}")\n\ndef save_bencoded_data(filepath: str, torrent_data: dict) -> str:\n    """Save bencoded data to a file, creating parent directories if necessary."""\n    copy_and_mkdir(filepath)\n    with open(filepath, "wb") as f:\n        f.write(bencoder.encode(torrent_data))\n    return filepath\n