import os\nimport re\nimport shutil\nimport pytest\nimport requests_mock\n\nfrom unittest.mock import MagicMock\nfrom colorama import Fore\n\nfrom .helpers import SetupTeardown, get_torrent_path, copy_and_mkdir\nfrom src.errors import TorrentExistsInClientError\nfrom src.scanner import scan_torrent_directory, scan_torrent_file\n\nclass TestScanTorrentFile(SetupTeardown):\n    def test_raises_error_if_torrent_file_does_not_exist(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_file("/tmp/nonexistent.torrent", "/tmp/output", red_api, ops_api, None)\n\n    def test_creates_output_directory_if_missing(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/new_output", red_api, ops_api, None)\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_returns_new_torrent_filepath(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            filepath = scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert os.path.isfile(filepath)\n        assert filepath == "/tmp/output/OPS/foo [OPS].torrent"\n\n    def test_calls_injector_if_injector_provided(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, injector_mock)\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/OPS/foo [OPS].torrent", "OPS"\n        )\n\n    def test_handles_duplicate_torrents_with_injector(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, injector_mock)\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/ops_source.torrent", "OPS"\n        )\n\n    def test_ignores_torrents_with_bad_encoding(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken_name"), "/tmp/output/broken_name.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\nclass TestScanTorrentDirectory(SetupTeardown):\n    def test_raises_error_if_input_directory_missing(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_directory("/tmp/nonexistent", "/tmp/output", red_api, ops_api, None)\n\n    def test_creates_output_directory_if_missing(self, red_api, ops_api):\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n        scan_torrent_directory("/tmp/input", "/tmp/new_output", red_api, ops_api, None)\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_reports_generated_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTGREEN_EX}Found with source 'OPS' and generated as '/tmp/output/OPS/foo [OPS].torrent'.{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTGREEN_EX}Generated for cross-seeding{Fore.RESET}: 1" in captured.out\n\n    def test_reports_undecodable_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("broken"), "/tmp/input/broken.torrent")\n\n        scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n        captured = capsys.readouterr()\n\n        assert f"{Fore.RED}Error decoding torrent file{Fore.RESET}" in captured.out\n        assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_reports_unknown_tracker_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("no_source"), "/tmp/input/no_source.torrent")\n\n        scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTBLACK_EX}Torrent not from OPS or RED based on source or announce URL{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTBLACK_EX}Skipped{Fore.RESET}: 1" in captured.out\n\n    def test_reports_already_existing_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/output/OPS/foo [OPS].torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated.{Fore.RESET}" in captured.out\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_considers_matching_input_torrents_as_existing(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/input/ops_source.torrent")\n\n        scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTYELLOW_EX}Torrent already exists in input directory at /tmp/input/red_source.torrent{Fore.RESET}"\n            in captured.out\n        )\n\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 2" in captured.out\n\n    def test_considers_matching_output_torrents_as_existing(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n        captured = capsys.readouterr()\n\n        assert f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated.{Fore.RESET}" in captured.out\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_calls_injector_on_duplicate(self, capsys, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, injector_mock)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated but was injected into your torrent client.{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/ops_source.torrent", "OPS"\n        )\n\n    def test_reports_torrents_existing_in_client(self, capsys, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        injector_mock.inject_torrent.side_effect = TorrentExistsInClientError("Torrent exists in client")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, injector_mock)\n            captured = capsys.readouterr()\n\n        assert f"{Fore.LIGHTYELLOW_EX}Torrent exists in client{Fore.RESET}" in captured.out\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_reports_not_found_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_KNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert f"{Fore.LIGHTRED_EX}Torrent could not be found on OPS{Fore.RESET}" in captured.out\n        assert f"{Fore.LIGHTRED_EX}Not found{Fore.RESET}: 1" in captured.out\n\n    def test_reports_unknown_error_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_UNKNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert f"{Fore.RED}An unknown error occurred in the API response from OPS{Fore.RESET}" in captured.out\n        assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_reports_progress_for_mixed_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("ops_announce"), "/tmp/input/ops_announce.torrent")\n        copy_and_mkdir(get_torrent_path("no_source"), "/tmp/input/no_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken"), "/tmp/input/broken.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert "Analyzed 3 local torrents" in captured.out\n\n        assert (\n            f"{Fore.LIGHTGREEN_EX}Found with source 'RED' and generated as '/tmp/output/RED/foo [RED].torrent'.{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTGREEN_EX}Generated for cross-seeding{Fore.RESET}: 1" in captured.out\n\n        assert (\n            f"{Fore.LIGHTBLACK_EX}Torrent not from OPS or RED based on source or announce URL{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTBLACK_EX}Skipped{Fore.RESET}: 1" in captured.out\n\n        assert f"{Fore.RED}Error decoding torrent file{Fore.RESET}" in captured.out\n        assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_ignores_non_torrent_files_in_input_directory(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/non-torrent.txt")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert "Analyzed 0 local torrents" in captured.out\n\n    def test_calls_injector_if_injector_provided(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, injector_mock)\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/OPS/foo [OPS].torrent", "OPS"\n        )\n\n    def test_ignores_torrents_with_bad_encoding(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken_name"), "/tmp/input/broken_name.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n