import os\nimport re\nimport shutil\nimport pytest\nimport requests_mock\nfrom unittest.mock import MagicMock\nfrom colorama import Fore\nfrom .helpers import SetupTeardown, get_torrent_path, copy_and_mkdir\nfrom src.errors import (\n    TorrentExistsInClientError,\n    TorrentDecodingError,\n    UnknownTrackerError,\n    TorrentNotFoundError,\n    TorrentAlreadyExistsError,\n)\nfrom src.scanner import scan_torrent_directory, scan_torrent_file\nfrom src.filesystem import assert_path_exists, mkdir_p, list_files_of_extension\nfrom src.parser import get_bencoded_data, calculate_infohash\n\nclass TestScanTorrentFile(SetupTeardown):\n    def test_gets_mad_if_torrent_file_does_not_exist(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_file(\n                "/tmp/nonexistent.torrent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n\n    def test_creates_output_directory_if_it_does_not_exist(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file(\n                "/tmp/input/red_source.torrent",\n                "/tmp/new_output",\n                red_api,\n                ops_api,\n                None\n            )\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_returns_torrent_filepath(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            filepath = scan_torrent_file(\n                "/tmp/input/red_source.torrent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n\n            assert os.path.isfile(filepath)\n            assert filepath == "/tmp/output/OPS/foo [OPS].torrent"\n\n    def test_calls_injector_if_provided(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file(\n                "/tmp/input/red_source.torrent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                injector_mock\n            )\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent",\n            "/tmp/output/OPS/foo [OPS].torrent",\n            "OPS"\n        )\n\n    def test_calls_injector_if_torrent_is_duplicate(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file(\n                "/tmp/input/red_source.torrent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                injector_mock\n            )\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent",\n            "/tmp/output/ops_source.torrent",\n            "OPS"\n        )\n\n    def test_doesnt_blow_up_if_other_torrent_name_has_bad_encoding(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken_name"), "/tmp/output/broken_name.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file(\n                "/tmp/input/red_source.torrent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n\nclass TestScanTorrentDirectory(SetupTeardown):\n    def test_gets_mad_if_input_directory_does_not_exist(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_directory(\n                "/tmp/nonexistent",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n\n    def test_creates_output_directory_if_it_does_not_exist(self, red_api, ops_api):\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n        scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/new_output",\n            red_api,\n            ops_api,\n            None\n        )\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_lists_generated_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert (\n                f"{Fore.LIGHTGREEN_EX}Found with source 'OPS' and generated as '/tmp/output/OPS/foo [OPS].torrent'.{Fore.RESET}"\n                in captured.out\n            )\n            assert f"{Fore.LIGHTGREEN_EX}Generated for cross-seeding{Fore.RESET}: 1" in captured.out\n\n    def test_lists_undecodable_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("broken"), "/tmp/input/broken.torrent")\n\n        result = scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/output",\n            red_api,\n            ops_api,\n            None\n        )\n        print(result)\n        captured = capsys.readouterr()\n\n        assert f"{Fore.RED}Error decoding torrent file{Fore.RESET}" in captured.out\n        assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_lists_unknown_tracker_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("no_source"), "/tmp/input/no_source.torrent")\n\n        result = scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/output",\n            red_api,\n            ops_api,\n            None\n        )\n        print(result)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTBLACK_EX}Torrent not from OPS or RED based on source or announce URL{Fore.RESET}" in captured.out\n        )\n        assert f"{Fore.LIGHTBLACK_EX}Skipped{Fore.RESET}: 1" in captured.out\n\n    def test_lists_already_existing_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/output/OPS/foo [OPS].torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated.{Fore.RESET}" in captured.out\n            assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_considers_matching_input_torrents_as_already_existing(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/input/ops_source.torrent")\n\n        result = scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/output",\n            red_api,\n            ops_api,\n            None\n        )\n        print(result)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTYELLOW_EX}Torrent already exists in input directory at /tmp/input/red_source.torrent{Fore.RESET}"\n            in captured.out\n        )\n\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 2" in captured.out\n\n    def test_considers_matching_output_torrents_as_already_existing(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        result = scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/output",\n            red_api,\n            ops_api,\n            None\n        )\n        print(result)\n        captured = capsys.readouterr()\n\n        assert f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated.{Fore.RESET}" in captured.out\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_returns_calls_injector_on_duplicate(self, capsys, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        result = scan_torrent_directory(\n            "/tmp/input",\n            "/tmp/output",\n            red_api,\n            ops_api,\n            injector_mock\n        )\n        print(result)\n        captured = capsys.readouterr()\n\n        assert (\n            f"{Fore.LIGHTYELLOW_EX}Torrent was previously generated but was injected into your torrent client.{Fore.RESET}"\n            in captured.out\n        )\n        assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent",\n            "/tmp/output/ops_source.torrent",\n            "OPS"\n        )\n\n    def test_lists_torrents_that_already_exist_in_client(self, capsys, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        injector_mock.inject_torrent.side_effect = TorrentExistsInClientError("Torrent exists in client")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                injector_mock\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert f"{Fore.LIGHTYELLOW_EX}Torrent exists in client{Fore.RESET}" in captured.out\n            assert f"{Fore.LIGHTYELLOW_EX}Already exists{Fore.RESET}: 1" in captured.out\n\n    def test_lists_not_found_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_KNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert f"{Fore.LIGHTRED_EX}Torrent could not be found on OPS{Fore.RESET}" in captured.out\n            assert f"{Fore.LIGHTRED_EX}Not found{Fore.RESET}: 1" in captured.out\n\n    def test_lists_unknown_error_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_UNKNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert f"{Fore.RED}An unknown error occurred in the API response from OPS{Fore.RESET}" in captured.out\n            assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_reports_progress_for_mix_of_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("ops_announce"), "/tmp/input/ops_announce.torrent")\n        copy_and_mkdir(get_torrent_path("no_source"), "/tmp/input/no_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken"), "/tmp/input/broken.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert "Analyzed 3 local torrents" in captured.out\n\n            assert (\n                f"{Fore.LIGHTGREEN_EX}Found with source 'RED' and generated as '/tmp/output/RED/foo [RED].torrent'.{Fore.RESET}"\n                in captured.out\n            )\n            assert f"{Fore.LIGHTGREEN_EX}Generated for cross-seeding{Fore.RESET}: 1" in captured.out\n\n            assert (\n                f"{Fore.LIGHTBLACK_EX}Torrent not from OPS or RED based on source or announce URL{Fore.RESET}" in captured.out\n            )\n            assert f"{Fore.LIGHTBLACK_EX}Skipped{Fore.RESET}: 1" in captured.out\n\n            assert f"{Fore.RED}Error decoding torrent file{Fore.RESET}" in captured.out\n            assert f"{Fore.RED}Errors{Fore.RESET}: 1" in captured.out\n\n    def test_doesnt_care_about_other_files_in_input_directory(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/non-torrent.txt")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            result = scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n            print(result)\n            captured = capsys.readouterr()\n\n            assert "Analyzed 0 local torrents" in captured.out\n\n    def test_calls_injector_if_provided(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                injector_mock\n            )\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent",\n            "/tmp/output/OPS/foo [OPS].torrent",\n            "OPS"\n        )\n\n    def test_doesnt_blow_up_if_other_torrent_name_has_bad_encoding(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken_name"), "/tmp/input/broken_name.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory(\n                "/tmp/input",\n                "/tmp/output",\n                red_api,\n                ops_api,\n                None\n            )\n