import os\nimport re\nimport shutil\nimport pytest\nimport requests_mock\n\nfrom unittest.mock import MagicMock\nfrom colorama import Fore\n\nfrom .helpers import SetupTeardown, get_torrent_path, copy_and_mkdir\nfrom src.errors import (\n    TorrentExistsInClientError,\n    TorrentDecodingError,\n    UnknownTrackerError,\n    TorrentAlreadyExistsError,\n    TorrentNotFoundError,\n)\nfrom src.scanner import scan_torrent_directory, scan_torrent_file\n\nclass TestScanTorrentFile(SetupTeardown):\n    def test_raises_file_not_found_error_if_torrent_file_does_not_exist(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_file("/tmp/nonexistent.torrent", "/tmp/output", red_api, ops_api, None)\n\n    def test_creates_output_directory_if_missing(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/new_output", red_api, ops_api, None)\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_returns_new_torrent_filepath(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            filepath = scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert os.path.isfile(filepath)\n        assert filepath == "/tmp/output/OPS/foo [OPS].torrent"\n\n    def test_calls_injector_if_injector_provided(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, injector_mock)\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/OPS/foo [OPS].torrent", "OPS"\n        )\n\n    def test_handles_duplicate_torrents_with_injector(self, red_api, ops_api):\n        injector_mock = MagicMock()\n        injector_mock.inject_torrent = MagicMock()\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("ops_source"), "/tmp/output/ops_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, injector_mock)\n\n        injector_mock.inject_torrent.assert_called_once_with(\n            "/tmp/input/red_source.torrent", "/tmp/output/ops_source.torrent", "OPS"\n        )\n\n    def test_ignores_torrents_with_bad_encoding(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("broken_name"), "/tmp/output/broken_name.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n    def test_raises_torrent_decoding_error_if_torrent_is_broken(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("broken"), "/tmp/input/broken.torrent")\n\n        with pytest.raises(TorrentDecodingError) as excinfo:\n            scan_torrent_file("/tmp/input/broken.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "Error decoding torrent file"\n\n    def test_raises_unknown_tracker_error_if_tracker_not_found(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("no_source"), "/tmp/input/no_source.torrent")\n\n        with pytest.raises(UnknownTrackerError) as excinfo:\n            scan_torrent_file("/tmp/input/no_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "Torrent not from OPS or RED based on source or announce URL"\n\n    def test_raises_torrent_already_exists_error_if_duplicate_in_input(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/another_red_source.torrent")\n\n        with pytest.raises(TorrentAlreadyExistsError) as excinfo:\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "Torrent already exists in input directory at /tmp/input/another_red_source.torrent"\n\n    def test_raises_torrent_already_exists_error_if_duplicate_in_output(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/output/OPS/foo [OPS].torrent")\n\n        with pytest.raises(TorrentAlreadyExistsError) as excinfo:\n            scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "Torrent already exists in output directory at /tmp/output/OPS/foo [OPS].torrent"\n\n    def test_raises_torrent_not_found_error_if_api_response_error(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_KNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            with pytest.raises(TorrentNotFoundError) as excinfo:\n                scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "Torrent could not be found on OPS"\n\n    def test_raises_unknown_error_if_api_response_unknown(self, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_UNKNOWN_BAD_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            with pytest.raises(Exception) as excinfo:\n                scan_torrent_file("/tmp/input/red_source.torrent", "/tmp/output", red_api, ops_api, None)\n\n        assert str(excinfo.value) == "An unknown error occurred in the API response from OPS"\n\nclass TestScanTorrentDirectory(SetupTeardown):\n    def test_raises_file_not_found_error_if_input_directory_missing(self, red_api, ops_api):\n        with pytest.raises(FileNotFoundError):\n            scan_torrent_directory("/tmp/nonexistent", "/tmp/output", red_api, ops_api, None)\n\n    def test_creates_output_directory_if_missing(self, red_api, ops_api):\n        shutil.rmtree("/tmp/new_output", ignore_errors=True)\n        scan_torrent_directory("/tmp/input", "/tmp/new_output", red_api, ops_api, None)\n\n        assert os.path.isdir("/tmp/new_output")\n        shutil.rmtree("/tmp/new_output")\n\n    def test_reports_generated_torrents(self, capsys, red_api, ops_api):\n        copy_and_mkdir(get_torrent_path("red_source"), "/tmp/input/red_source.torrent")\n\n        with requests_mock.Mocker() as m:\n            m.get(re.compile("action=torrent"), json=self.TORRENT_SUCCESS_RESPONSE)\n            m.get(re.compile("action=index"), json=self.ANNOUNCE_SUCCESS_RESPONSE)\n\n            scan_torrent_directory("/tmp/input", "/tmp/output", red_api, ops_api, None)\n            captured = capsys.readouterr()\n\n        assert (\